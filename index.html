<!DOCTYPE html>

<html class="dark" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Drum-Bit</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Drum-Bit" />
    <meta property="og:description" content="ðŸŽ›ï¸ A web-based drum machine that lets you create and share beat patterns using 16-bit numbers." />
    <meta property="og:image" content="favicon.svg" />
    <meta property="og:image:width" content="512" />
    <meta property="og:image:height" content="512" />
    <meta property="og:url" content="" />
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary" />
    <meta property="twitter:title" content="Drum-Bit" />
    <meta property="twitter:description" content="ðŸŽ›ï¸ A web-based drum machine that lets you create and share beat patterns using 16-bit numbers." />
    <meta property="twitter:image" content="favicon.svg" />
    <meta property="twitter:image:width" content="512" />
    <meta property="twitter:image:height" content="512" />
    
    <link rel="stylesheet" href="styles.css" />
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
  </head>
  <body class="dark">
    <div class="container" x-data="drumMachine()">
      <header class="header">
        <button class="play-button" @click="togglePlay()">
          <i x-show="!isPlaying" data-lucide="play" width="24" height="24" x-ref="playIcon"></i>
          <i x-show="isPlaying" data-lucide="square" width="24" height="24" x-ref="stopIcon"></i>
        </button>
        <div class="controls">
          <input class="bpm-input" type="number" x-model="bpm" min="20" max="240" @input="updateURL()" />
          <button class="tap-button" @click="tapTempo()">TAP</button>
        </div>
      </header>
      <main class="main">
        <div class="tracks">
          <template x-for="(track, index) in tracks" :key="index">
            <div class="track">
              <div class="track-header">
                <span class="track-name" x-text="track.name" @click="playSample(track)" style="cursor: pointer;"></span>
                <div class="sequence-control">
                  <input
                    class="sequence-slider"
                    max="65535"
                    min="0"
                    type="range"
                    x-model="track.sequence"
                    @input="updateStepsFromSequence(track)"
                  />
                </div>
                <input class="sequence-number" type="number" x-model="track.sequence" min="0" max="65535" 
                       @input="updateStepsFromSequence(track)" />
                <button class="shuffle-button" @click="shuffleTrack(track)" title="Shuffle pattern">
                  <i data-lucide="shuffle" width="16" height="16"></i>
                </button>
              </div>
              <div class="step-grid">
                <template x-for="(step, index) in track.steps" :key="index">
                  <div 
                    class="step"
                    :class="{
                      'step-active': step.active,
                      'playing': currentStep === index && isPlaying,
                      'step-group-light': Math.floor(index / 4) % 2 === 0,
                      'step-group-dark': Math.floor(index / 4) % 2 === 1
                    }"
                    @click="toggleStep(track, index)"
                  ></div>
                </template>
              </div>
            </div>
          </template>
        </div>
      </main>

    </div>
    <script type="module">
      import { combine, split, encode, decode } from './packer.js';
      import { default as Alpine } from 'https://cdn.jsdelivr.net/npm/alpinejs@3/+esm'

      Alpine.data('drumMachine', drumMachine);
      Alpine.start()

      // Alpine.js data
      function drumMachine() {
        return {
          isPlaying: false,
          bpm: 120,
          currentStep: 0,
          lastStepTime: 0,
          audioContext: null,
          audioBuffers: {},
          activeHiHat: null, // For choke group
          
          // Velocity configuration (easy to adjust)
          normalVelocity: 1.0,    // Normal hit volume (1.0 = 100%)
          accentVelocity: 1.75,    // Accented hit volume (1.5 = 150%)
          
          tracks: [
            {
              name: 'Snare',
              sample: 'samples/SD.wav',
              sequence: 4112, // 0000100000001000 
            },
            {
              name: 'Kick',
              sample: 'samples/KD.wav',
              sequence: 321, // 1000001010000000
            },
            {
              name: 'Closed HH',
              sample: 'samples/CHH.wav',
              chokeGroup: 'hihat',
              sequence: 1092, // 0010001000100000
            },
            {
              name: 'Open HH',
              sample: 'samples/OHH.wav',
              chokeGroup: 'hihat',
              sequence: 16384, // 0000000000000010
            },
            {
              name: 'High Tom',
              sample: 'samples/HT.wav',
              sequence: 0,
            },
            // {
            //   name: 'Mid Tom',
            //   sample: 'samples/MT.wav',
            //   sequence: 0,
            // },
            {
              name: 'Low Tom',
              sample: 'samples/LT.wav',
              sequence: 0,
            },
            {
              name: 'Accent',
              sample: null, // Accent doesn't produce sound itself
              isAccent: true,
              sequence: 0,
            }
          ],
          
          // Initialize sequence numbers from step patterns
          async init() {
            console.log('Initializing drum machine...');

            // Load state from URL first (if present, it will override default sequences)
            this.loadStateFromURL();
            
            // Generate steps array from sequence numbers for all tracks
            this.tracks.forEach(track => {
              if (!track.steps) {
                // Initialize empty steps array
                track.steps = [];
                for (let i = 0; i < 16; i++) {
                  track.steps.push({ active: false });
                }
              }
              // Use existing function to populate steps from sequence
              this.updateStepsFromSequence(track);
            });
            
            await this.initAudio();
            // Initialize icons after Alpine.js has rendered
            this.$nextTick(() => {
              lucide.createIcons();
            });
          },
          
          // Load state from URL hash
          loadStateFromURL() {
            const hash = window.location.hash.substring(1); // Remove #
            if (!hash) return;
            
            try {
              // Decode base62 to BigInt
              const bigIntValue = decode(hash);
              
              // Split into array: [BPM, Track1, Track2, ..., Track7]
              // Total: 8 numbers (1 BPM + 7 tracks)
              const numbers = split(bigIntValue, 8);
              
              // First number is BPM
              const bpm = numbers[0];
              if (bpm >= 20 && bpm <= 240) {
                this.bpm = bpm;
              }
              
              // Remaining numbers are track sequences
              for (let i = 1; i < numbers.length && i - 1 < this.tracks.length; i++) {
                const sequence = numbers[i];
                if (sequence >= 0 && sequence <= 65535) {
                  this.tracks[i - 1].sequence = sequence;
                  this.updateStepsFromSequence(this.tracks[i - 1]);
                }
              }
            } catch (error) {
              console.warn('Failed to load state from URL:', error);
            }
          },
          
          // Update URL with current state
          updateURL() {
            // Combine BPM and all track sequences into array
            const numbers = [this.bpm];
            this.tracks.forEach(track => {
              numbers.push(track.sequence);
            });
            
            // Combine into BigInt and encode to base62
            const bigIntValue = combine(numbers);
            const hash = encode(bigIntValue);
            
            // Update URL without reloading page
            if (window.history.replaceState) {
              const newURL = window.location.pathname + window.location.search + '#' + hash;
              window.history.replaceState(null, '', newURL);
            } else {
              window.location.hash = hash;
            }
          },
          
          // Initialize Web Audio API and load samples
          async initAudio() {
            try {
              this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
              
              // Load all unique samples
              const uniqueSamples = [...new Set(this.tracks.map(track => track.sample))];
              
              for (const samplePath of uniqueSamples) {
                try {
                  const response = await fetch(samplePath);
                  const arrayBuffer = await response.arrayBuffer();
                  const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                  this.audioBuffers[samplePath] = audioBuffer;
                } catch (error) {
                  console.warn(`Failed to load sample: ${samplePath}`, error);
                }
              }
            } catch (error) {
              console.warn('Audio initialization failed:', error);
            }
          },
          
          // Play a sample with choke group support
          playSample(track, when = 0, velocity = 1.0) {
            if (!this.audioContext || !track.sample || !this.audioBuffers[track.sample]) return;
            
            // Handle choke groups (stop other sounds in the same group)
            if (track.chokeGroup) {
              if (this.activeHiHat) {
                this.activeHiHat.stop();
              }
            }
            
            const source = this.audioContext.createBufferSource();
            source.buffer = this.audioBuffers[track.sample];
            
            // Create a gain node for volume control
            const gainNode = this.audioContext.createGain();
            gainNode.gain.value = velocity;
            
            source.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            source.start(when);
            
            // Store reference for choke group
            if (track.chokeGroup === 'hihat') {
              this.activeHiHat = source;
              source.onended = () => {
                if (this.activeHiHat === source) {
                  this.activeHiHat = null;
                }
              };
            }
          },
          
          // Play a sample at a scheduled time (for precise timing)
          playScheduledSample(track, when, velocity = 1.0) {
            if (!this.audioContext || !track.sample || !this.audioBuffers[track.sample]) return;
            
            // Handle choke groups for scheduled playback
            if (track.chokeGroup === 'hihat' && this.activeHiHat) {
              this.activeHiHat.stop(when);
            }
            
            const source = this.audioContext.createBufferSource();
            source.buffer = this.audioBuffers[track.sample];
            
            // Create a gain node for volume control
            const gainNode = this.audioContext.createGain();
            gainNode.gain.value = velocity;
            
            source.connect(gainNode);
            gainNode.connect(this.audioContext.destination);
            source.start(when);
            
            // Store reference for choke group
            if (track.chokeGroup === 'hihat') {
              this.activeHiHat = source;
              source.onended = () => {
                if (this.activeHiHat === source) {
                  this.activeHiHat = null;
                }
              };
            }
          },
          
          togglePlay() {
            this.isPlaying = !this.isPlaying;
            if (this.isPlaying) {
              // Resume audio context if suspended (required by browsers)
              if (this.audioContext && this.audioContext.state === 'suspended') {
                this.audioContext.resume();
              }
              this.startSequencer();
            } else {
              this.stopSequencer();
            }
            // Only recreate icons when play state changes
            this.$nextTick(() => {
              lucide.createIcons();
            });
          },
          
          startSequencer() {
            this.startTime = this.audioContext.currentTime;
            this.nextStepTime = this.startTime;
            this.lastScheduledStep = -1;
            
            // Start the scheduling loop
            this.tick();
          },
          
          tick() {
            if (!this.isPlaying) return;
            
            // Calculate current step from audio time (single source of truth)
            const stepDuration = 60 / this.bpm / 4;
            const elapsed = this.audioContext.currentTime - this.startTime;
            const calculatedStep = Math.floor(elapsed / stepDuration) % 16;
            
            // Update visual step
            if (calculatedStep >= 0 && calculatedStep !== this.currentStep) {
              this.currentStep = calculatedStep;
            }
            
            // Schedule audio samples ahead
            this.scheduleAhead();
            
            // Continue the loop
            requestAnimationFrame(() => this.tick());
          },
          
          scheduleAhead(lookAhead = 0.1) {
            const stepDuration = 60 / this.bpm / 4;
            
            while (this.nextStepTime < this.audioContext.currentTime + lookAhead) {
              // Use the same calculation as visual step for consistency
              const stepIndex = Math.floor((this.nextStepTime - this.startTime) / stepDuration) % 16;
              
              // Only schedule if we haven't already scheduled this step time
              const stepKey = Math.floor(this.nextStepTime * 1000); // Use time as key
              if (stepKey !== this.lastScheduledStep) {
                // Check if accent is active on this step
                const accentTrack = this.tracks.find(t => t.isAccent);
                const isAccented = accentTrack && accentTrack.steps[stepIndex].active;
                
                // Use configurable velocity values
                const velocity = isAccented ? this.accentVelocity : this.normalVelocity;
                
                this.tracks.forEach(track => {
                  // Skip the accent track itself (it doesn't produce sound)
                  if (!track.isAccent && track.steps[stepIndex].active) {
                    this.playScheduledSample(track, this.nextStepTime, velocity);
                  }
                });
                this.lastScheduledStep = stepKey;
              }
              
              // Move to next step
              this.nextStepTime += stepDuration;
            }
          },
          
          stopSequencer() {
            this.isPlaying = false;
            this.currentStep = 0;
            this.lastScheduledStep = -1;
          },
          
          toggleStep(track, stepIndex) {
            const step = track.steps[stepIndex];
            step.active = !step.active;
            // Update sequence number when step is toggled
            this.updateSequenceFromSteps(track);
            // Update URL with new state
            this.updateURL();
          },
          
          // Convert sequence number to step pattern
          updateStepsFromSequence(track) {
            const sequence = parseInt(track.sequence) || 0;
            for (let i = 0; i < 16; i++) {
              track.steps[i].active = (sequence & (1 << i)) !== 0;
            }
            // Update URL when sequence is changed via input/slider
            this.updateURL();
          },
          
          // Convert step pattern to sequence number
          updateSequenceFromSteps(track) {
            let sequence = 0;
            for (let i = 0; i < 16; i++) {
              if (track.steps[i].active) {
                sequence |= (1 << i);
              }
            }
            track.sequence = sequence;
          },
          
          tapTempo() {
            const now = Date.now();
            if (!this.lastTap) {
              this.lastTap = now;
              return;
            }
            
            const timeDiff = now - this.lastTap;
            const newBpm = Math.round(60000 / timeDiff);
            
            if (newBpm >= 20 && newBpm <= 240) {
              this.bpm = newBpm;
              this.updateURL();
            }
            
            this.lastTap = now;
          },
          
          shuffleTrack(track) {
            // Generate random 16-bit number (0-65535)
            const randomSequence = Math.floor(Math.random() * 65536);
            track.sequence = randomSequence;
            this.updateStepsFromSequence(track);
            // Update URL with new state
            this.updateURL();
            // Refresh icons after DOM update
            this.$nextTick(() => {
              lucide.createIcons();
            });
          }
        }
      }
    </script>
  </body>
</html>
